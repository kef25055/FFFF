import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as e,b as i,w as n,d as s,r as l,o,e as h}from"./app-BAwCCQWy.js";const c={},p={class:"hint-container tip"};function g(m,t){const d=l("RouteLink");return o(),r("div",null,[t[2]||(t[2]=e("h1",{id:"多线程编程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#多线程编程"},[e("span",null,"多线程编程")])],-1)),t[3]||(t[3]=e("h2",{id:"一、操作系统中的进程与线程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、操作系统中的进程与线程"},[e("span",null,"一、操作系统中的进程与线程")])],-1)),t[4]||(t[4]=e("p",null,"在另一篇里介绍过了",-1)),e("div",p,[t[1]||(t[1]=e("p",{class:"hint-container-title"},"点击查看👇",-1)),e("p",null,[i(d,{to:"/blog/learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html"},{default:n(()=>t[0]||(t[0]=[h("操作系统中的进程与线程")])),_:1})])]),t[5]||(t[5]=s('<h2 id="二、为什么使用多线程" tabindex="-1"><a class="header-anchor" href="#二、为什么使用多线程"><span>二、为什么使用多线程？</span></a></h2><p><strong>多线程</strong>是一种允许程序<strong>并发执行多个任务</strong>的技术。相比多进程，它更加轻质量，可以提高程序在多核 CPU 上的执行效率。</p><h2 id="_1-单线程的局限" tabindex="-1"><a class="header-anchor" href="#_1-单线程的局限"><span>1.单线程的局限</span></a></h2><ul><li>执行任务被阻塞（如读取文件、等待网络）</li><li>无法利用多核 CPU</li><li>响应慢、效率低</li></ul><h2 id="_2-多线程的优势" tabindex="-1"><a class="header-anchor" href="#_2-多线程的优势"><span>2.多线程的优势</span></a></h2><ul><li>任务并发执行，响应更快</li><li>提高 CPU 使用率</li><li>解耦复杂逻辑（界面、计算、IO 分离）</li></ul><h2 id="三、c-中的多线程" tabindex="-1"><a class="header-anchor" href="#三、c-中的多线程"><span>三、C++中的多线程</span></a></h2><p>在 C++11 之后，标准库引入了 <code>std::thread</code> 类来进行多线程编程。</p><h2 id="🎯std-thread-常用函数" tabindex="-1"><a class="header-anchor" href="#🎯std-thread-常用函数"><span>🎯<code>std::thread</code> 常用函数</span></a></h2><table><thead><tr><th>函数</th><th>类别</th><th>功能简介</th></tr></thead><tbody><tr><td><code>std::thread()</code></td><td>构造函数</td><td>默认构造，不启动任何线程</td></tr><tr><td><code>std::thread(Fn&amp;&amp; f, Args&amp;&amp;... args)</code></td><td>构造函数</td><td>创建线程并异步执行函数 <code>f(args...)</code></td></tr><tr><td><code>~thread()</code></td><td>析构函数</td><td>销毁线程对象，若线程仍可 joinable 未处理，会调用 <code>std::terminate()</code></td></tr><tr><td><code>join()</code></td><td>成员函数</td><td>阻塞当前线程，直到该线程执行完毕并回收资源</td></tr><tr><td><code>detach()</code></td><td>成员函数</td><td>将线程与 <code>std::thread</code> 对象分离，后台运行，不可再 <code>join()</code></td></tr><tr><td><code>joinable()</code></td><td>成员函数</td><td>检查线程是否处于可 join 状态</td></tr><tr><td><code>get_id()</code></td><td>成员函数</td><td>获取线程的唯一 ID，用于调试或标识线程</td></tr><tr><td><code>thread(thread&amp;&amp; other)</code></td><td>移动构造</td><td>移动构造函数，将线程所有权从 <code>other</code> 转移</td></tr><tr><td><code>operator=(thread&amp;&amp; other)</code></td><td>移动赋值</td><td>移动赋值操作，同样实现线程对象所有权转移</td></tr><tr><td><code>std::thread::hardware_concurrency()</code></td><td>静态函数</td><td>返回系统建议的并发线程数（即 CPU 核心数，结果可能为 0）</td></tr></tbody></table><h3 id="_1-std-thread-默认构造函数" tabindex="-1"><a class="header-anchor" href="#_1-std-thread-默认构造函数"><span>1.<code>std::thread()</code>默认构造函数</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::thread t;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 创建一个不绑定任何任务的空线程对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>📌作用：构造一个空的 <code>thread</code> 对象，可以后续再赋值移动进其他线程。</p><h3 id="_2-std-thread-fn-f-args-args-创建线程" tabindex="-1"><a class="header-anchor" href="#_2-std-thread-fn-f-args-args-创建线程"><span>2.<code>std::thread(Fn&amp;&amp; f, Args&amp;&amp;... args)</code>创建线程</span></a></h3>',14))])}const f=a(c,[["render",g],["__file","多线程编程.html.vue"]]),k=JSON.parse('{"path":"/blog/learning/C__/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html","title":"多线程编程","lang":"zh-CN","frontmatter":{"title":"多线程编程","categories":["C++","多线程"],"order":2,"description":"多线程编程 一、操作系统中的进程与线程 在另一篇里介绍过了 点击查看👇 二、为什么使用多线程？ 多线程是一种允许程序并发执行多个任务的技术。相比多进程，它更加轻质量，可以提高程序在多核 CPU 上的执行效率。 1.单线程的局限 执行任务被阻塞（如读取文件、等待网络） 无法利用多核 CPU 响应慢、效率低 2.多线程的优势 任务并发执行，响应更快 提高...","head":[["meta",{"property":"og:url","content":"https://github.com/kef25055/FFFF/blog/learning/C__/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"小鸡很方"}],["meta",{"property":"og:title","content":"多线程编程"}],["meta",{"property":"og:description","content":"多线程编程 一、操作系统中的进程与线程 在另一篇里介绍过了 点击查看👇 二、为什么使用多线程？ 多线程是一种允许程序并发执行多个任务的技术。相比多进程，它更加轻质量，可以提高程序在多核 CPU 上的执行效率。 1.单线程的局限 执行任务被阻塞（如读取文件、等待网络） 无法利用多核 CPU 响应慢、效率低 2.多线程的优势 任务并发执行，响应更快 提高..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-07T10:31:08.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-07T10:31:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多线程编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-07T10:31:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小鸡很方\\",\\"url\\":\\"https://github.com/kef25055\\"}]}"]]},"headers":[{"level":2,"title":"一、操作系统中的进程与线程","slug":"一、操作系统中的进程与线程","link":"#一、操作系统中的进程与线程","children":[]},{"level":2,"title":"二、为什么使用多线程？","slug":"二、为什么使用多线程","link":"#二、为什么使用多线程","children":[]},{"level":2,"title":"1.单线程的局限","slug":"_1-单线程的局限","link":"#_1-单线程的局限","children":[]},{"level":2,"title":"2.多线程的优势","slug":"_2-多线程的优势","link":"#_2-多线程的优势","children":[]},{"level":2,"title":"三、C++中的多线程","slug":"三、c-中的多线程","link":"#三、c-中的多线程","children":[]},{"level":2,"title":"🎯std::thread 常用函数","slug":"🎯std-thread-常用函数","link":"#🎯std-thread-常用函数","children":[{"level":3,"title":"1.std::thread()默认构造函数","slug":"_1-std-thread-默认构造函数","link":"#_1-std-thread-默认构造函数","children":[]},{"level":3,"title":"2.std::thread(Fn&& f, Args&&... args)创建线程","slug":"_2-std-thread-fn-f-args-args-创建线程","link":"#_2-std-thread-fn-f-args-args-创建线程","children":[]}]}],"git":{"createdTime":1743831464000,"updatedTime":1744021868000,"contributors":[{"name":"小鸡很方","email":"fang-kk@qq.com","commits":2}]},"readingTime":{"minutes":1.8,"words":539},"filePathRelative":"blog/learning/C++/多线程编程.md","localizedDate":"2025年4月5日","excerpt":"\\n<h2>一、操作系统中的进程与线程</h2>\\n<p>在另一篇里介绍过了</p>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">点击查看👇</p>\\n<p><a href=\\"/FFFF/blog/learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html\\" target=\\"_blank\\">操作系统中的进程与线程</a></p>\\n</div>\\n<h2>二、为什么使用多线程？</h2>","autoDesc":true}');export{f as comp,k as data};
