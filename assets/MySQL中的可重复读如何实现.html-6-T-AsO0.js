import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as o,o as a}from"./app-CLsBImKY.js";const l={};function n(r,e){return a(),t("div",null,e[0]||(e[0]=[o('<h1 id="mysql中的可重复读如何实现" tabindex="-1"><a class="header-anchor" href="#mysql中的可重复读如何实现"><span>MySQL中的可重复读如何实现</span></a></h1><h2 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc"><span>MVCC</span></a></h2><ul><li>MVCC，多版本并发控制，用于实现<strong>读已提交</strong>和<strong>可重复读</strong>隔离级别。</li><li>MVCC 的核心就是 Undo log 多版本链 + ReadView， &quot;MV&quot; 就是通过 Undo log 来保存数据的历史版本，实现多版本的管理， &quot;CC&quot; 是通过 ReadView 来实现管理，通过 ReadView 原则来决定数据是否显示。 同时针对不同的隔离级别，ReadView 的生成策略不同，也就实现了不同的隔离级别。</li></ul><h2 id="undo-log-多版本链" tabindex="-1"><a class="header-anchor" href="#undo-log-多版本链"><span>Undo log 多版本链</span></a></h2><p>每条数据都有两个隐藏字段：</p><ul><li><code>trx_id</code>:事务 id，记录最近一次更新这条数据的事务 id</li><li><code>roll_pointer</code>:回滚指针，指向之前生成的 undo log</li></ul><figure><img src="https://github.com/kef25055/Typoraimg/blob/main/blog/learning/数据库/1.png?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每一条数据都有多个版本，版本之间通过 undo log 链条进行连接。</p><h2 id="readview" tabindex="-1"><a class="header-anchor" href="#readview"><span>ReadView</span></a></h2><p>ReadView 是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistant read view， 用于支持 RC(Read Committed 读提交) 和 RR(Repeatable Read 可重复读) 隔离级别的实现。</p><p>ReadView 简单理解就是对数据在某个时刻的状态记录下来。之后获取某时刻的数据就是还原记录的状态，是不会变的。</p><p>ReadView 中比较重要的字段有 4 个：</p><ul><li><code>m_ids</code>：用来表示 MySQL 中哪些事务正在执行，但是没有提交。</li><li><code>min_trx_id</code>：就是 <code>m_ids</code> 里最小的值。</li><li><code>max_trx_id</code>：<strong>下一个</strong>要生成的事务 id 值，也就是最大事务 id。</li><li><code>creator_trx_id</code>：当前事务 id。</li></ul><p>当一个事务第一次执行查询 sql 时，会生成一致性视图 read-view（快照）， 查询时从 undo log 中最新的一条记录开始跟 read-view 做对比。 如果不符合比较规则，就根据回滚指针回滚到上一条记录继续比较，直到得到符合条件的查询结果。</p><p><strong>ReadView 判断记录某个版本是否可见的规则如下：</strong></p><figure><img src="https://github.com/kef25055/Typoraimg/blob/main/blog/learning/数据库/2.png?raw=true" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>如果当前记录的事务 id 落在左侧部分，表示这个版本已经是已提交的事务生成的，可读。</li><li>如果当前记录的事务 id 落在右侧部分，表示这个版本是由将来启动的事务生成的，不可读。</li><li>如果当前记录的事务 id 落在中间部分，则分为两种情况： <ul><li>若当前记录的事务 id 在未提交事务的数组中，则此条记录不可读。</li><li>若当前记录的事务 id 不在未提交事务的数组中，则此条记录可读。</li></ul></li></ul><p>RC 和 RR 隔离级别都是由 MVCC 实现，区别在于：</p><ul><li>RC 隔离级别中，read-view 是每次执行 select 语句时都生成一个</li><li>RR 隔离级别中，read-view 是在第一次执行 select 语句时生成一个，同一事务中后面的所有 select 语句都复用这个 read-view</li></ul>',19)]))}const c=i(l,[["render",n],["__file","MySQL中的可重复读如何实现.html.vue"]]),p=JSON.parse('{"path":"/blog/learning/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0.html","title":"MySQL中的可重复读如何实现","lang":"zh-CN","frontmatter":{"title":"MySQL中的可重复读如何实现","categories":["数据库"],"tags":["MySQL","可重复读"],"order":2,"description":"MySQL中的可重复读如何实现 MVCC MVCC，多版本并发控制，用于实现读已提交和可重复读隔离级别。 MVCC 的核心就是 Undo log 多版本链 + ReadView， \\"MV\\" 就是通过 Undo log 来保存数据的历史版本，实现多版本的管理， \\"CC\\" 是通过 ReadView 来实现管理，通过 ReadView 原则来决定数据是否显示...","head":[["meta",{"property":"og:url","content":"https://github.com/kef25055/FFFF/blog/learning/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"小鸡很方"}],["meta",{"property":"og:title","content":"MySQL中的可重复读如何实现"}],["meta",{"property":"og:description","content":"MySQL中的可重复读如何实现 MVCC MVCC，多版本并发控制，用于实现读已提交和可重复读隔离级别。 MVCC 的核心就是 Undo log 多版本链 + ReadView， \\"MV\\" 就是通过 Undo log 来保存数据的历史版本，实现多版本的管理， \\"CC\\" 是通过 ReadView 来实现管理，通过 ReadView 原则来决定数据是否显示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/kef25055/Typoraimg/blob/main/blog/learning/%E6%95%B0%E6%8D%AE%E5%BA%93/1.png?raw=true"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-08T01:17:56.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"可重复读"}],["meta",{"property":"article:modified_time","content":"2025-04-08T01:17:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL中的可重复读如何实现\\",\\"image\\":[\\"https://github.com/kef25055/Typoraimg/blob/main/blog/learning/%E6%95%B0%E6%8D%AE%E5%BA%93/1.png?raw=true\\",\\"https://github.com/kef25055/Typoraimg/blob/main/blog/learning/%E6%95%B0%E6%8D%AE%E5%BA%93/2.png?raw=true\\"],\\"dateModified\\":\\"2025-04-08T01:17:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小鸡很方\\",\\"url\\":\\"https://github.com/kef25055\\"}]}"]]},"headers":[{"level":2,"title":"MVCC","slug":"mvcc","link":"#mvcc","children":[]},{"level":2,"title":"Undo log 多版本链","slug":"undo-log-多版本链","link":"#undo-log-多版本链","children":[]},{"level":2,"title":"ReadView","slug":"readview","link":"#readview","children":[]}],"git":{"createdTime":1744031459000,"updatedTime":1744075076000,"contributors":[{"name":"小鸡很方","email":"fang-kk@qq.com","commits":5}]},"readingTime":{"minutes":2.52,"words":757},"filePathRelative":"blog/learning/数据库/MySQL中的可重复读如何实现.md","localizedDate":"2025年4月7日","excerpt":"\\n<h2>MVCC</h2>\\n<ul>\\n<li>MVCC，多版本并发控制，用于实现<strong>读已提交</strong>和<strong>可重复读</strong>隔离级别。</li>\\n<li>MVCC 的核心就是 Undo log 多版本链 + ReadView，\\n\\"MV\\" 就是通过 Undo log 来保存数据的历史版本，实现多版本的管理，\\n\\"CC\\" 是通过 ReadView 来实现管理，通过 ReadView 原则来决定数据是否显示。\\n同时针对不同的隔离级别，ReadView 的生成策略不同，也就实现了不同的隔离级别。</li>\\n</ul>\\n<h2>Undo log 多版本链</h2>","autoDesc":true}');export{c as comp,p as data};
