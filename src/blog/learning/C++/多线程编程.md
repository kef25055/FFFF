---
title: 多线程编程
categories:
  - C++
  - 多线程
order: 2
---

# 多线程编程

## 一、操作系统中的进程与线程

在另一篇里介绍过了

::: tip 点击查看👇
[操作系统中的进程与线程](../操作系统/进程与线程.md)
:::

## 二、为什么使用多线程？

**多线程**是一种允许程序**并发执行多个任务**的技术。相比多进程，它更加轻质量，可以提高程序在多核 CPU 上的执行效率。

## 1.单线程的局限
- 执行任务被阻塞（如读取文件、等待网络）
- 无法利用多核 CPU
- 响应慢、效率低

## 2.多线程的优势
- 任务并发执行，响应更快
- 提高 CPU 使用率
- 解耦复杂逻辑（界面、计算、IO 分离）

## 三、C++中的多线程

在 C++11 之后，标准库引入了 `std::thread` 类来进行多线程编程。

## 🎯`std::thread` 常用函数
| 函数                                    | 类别   | 功能简介                                                                 |
|-------------------------------------------|------|--------------------------------------------------------------------------|
| `std::thread()`                           | 构造函数 | 默认构造，不启动任何线程                                                |
| `std::thread(Fn&& f, Args&&... args)`     | 构造函数 | 创建线程并异步执行函数 `f(args...)`                                     |
| `~thread()`                               | 析构函数 | 销毁线程对象，若线程仍可 joinable 未处理，会调用 `std::terminate()`     |
| `join()`                                  | 成员函数 | 阻塞当前线程，直到该线程执行完毕并回收资源                              |
| `detach()`                                | 成员函数 | 将线程与 `std::thread` 对象分离，后台运行，不可再 `join()`              |
| `joinable()`                              | 成员函数 | 检查线程是否处于可 join 状态                                            |
| `get_id()`                                | 成员函数 | 获取线程的唯一 ID，用于调试或标识线程                                   |
| `thread(thread&& other)`                  | 移动构造 | 移动构造函数，将线程所有权从 `other` 转移                               |
| `operator=(thread&& other)`               | 移动赋值 | 移动赋值操作，同样实现线程对象所有权转移                                |
| `std::thread::hardware_concurrency()`     | 静态函数 | 返回系统建议的并发线程数（即 CPU 核心数，结果可能为 0）                  |

### 1.`std::thread()`默认构造函数 
```cpp
std::thread t; // 创建一个不绑定任何任务的空线程对象
```
📌作用：构造一个空的 `thread` 对象，可以后续再赋值移动进其他线程。

### 2.`std::thread(Fn&& f, Args&&... args)`创建线程
