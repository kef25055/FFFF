---
title: 智能指针
categories:
  - C++
  - 智能指针
tags:
  - auto_ptr
  - unique_ptr
  - shared_ptr
  - weak_ptr
order: 1
---

# 智能指针

## std::auto_ptr

### 基本原理

`auto_ptr` 通过**管理权转移**的方式解决智能指针的拷贝问题，
保证一个资源在任何时刻都只有一个对象在对其进行管理，
这时同一个资源就不会被多次释放了。


如下，$ap1$ 赋值给 $ap2$ 后，将内存管理权转移给 $ap2$, 
此时 $ap1$ 指针为 `nullptr`。

```cpp
int main() 
{
	std::auto_ptr<int> ap1(new int(1));
	std::auto_ptr<int> ap2(ap1);
	*ap2 = 10;
	//*ap1 = 20; //error
	return 0;
}
```

但一个对象的管理权转移后也就意味着，该对象不能再用对原来管理的资源进行访问了，
否则程序就会崩溃，因此使用 `auto_ptr` 之前必须先了解它的机制，否则程序很容易出问题，
很多公司也都明确规定了禁止使用 `auto_ptr`。

### 模拟实现

简易版的 `auto_ptr` 的实现步骤如下：

1. 在构造函数中获取资源，在析构函数中释放资源，利用对象的生命周期来控制资源。

2. 对 `*` 和 `->` 运算符进行重载，使 `auto_ptr` 对象具有指针一样的行为。

3. 在拷贝构造函数中，用传入对象管理的资源来构造当前对象，并将传入对象管理资源的指针置空。

4. 在拷贝赋值函数中，先将当前对象管理的资源释放，然后再接管传入对象管理的资源，最后将传入对象管理资源的指针置空。

代码如下：
```cpp
namespace ff
{
	template<class T>
	class auto_ptr
	{
	public:
		//RAII
		auto_ptr(T* ptr = nullptr)
			:m_ptr(ptr)
		{}
		~auto_ptr()
		{
			if (m_ptr != nullptr)
			{
				std::cout << "delete: " << m_ptr << std::endl;
				delete m_ptr;
				m_ptr = nullptr;
			}
		}
		auto_ptr(auto_ptr<T>& ap)
			:m_ptr(ap.m_ptr)
		{
			ap.m_ptr = nullptr; //管理权转移后ap置空
		}
		auto_ptr<T>& operator=(auto_ptr<T>& ap)
		{
			if (this != &ap)
			{
				delete m_ptr;		//释放自己管理的资源
				m_ptr = ap.m_ptr;	//接管ap的资源
				ap.m_ptr = nullptr;	//管理权转移后ap置空
			}
			return *this;
		}
		//可以像指针一样使用
		T& operator*()
		{
			return *m_ptr;
		}
		T* operator->()
		{
			return &m_ptr;
		}
	private:
		T* m_ptr; //管理的资源
	};
}
```

## std::unique_ptr

### 基本原理

`unique_ptr` 通过**防拷贝**的方式解决智能指针的拷贝问题，
也就是简单粗暴的防止对智能指针对象进行拷贝，
这样也能保证资源不会被多次释放。如下:

```cpp
int main()
{
	std::unique_ptr<int> up1 = std::make_unique<int>(0);
	//std::unique_ptr<int> up2(up1); //error
	return 0;
}
```

但防拷贝其实也不是一个很好的办法，因为总有一些场景需要进行拷贝。
如果想要“共享”指针的时候，就需要用到 `shared_ptr` 了。

### 模拟实现

简易版的 `unique_ptr` 的实现步骤如下：

1. 在构造函数中获取资源，在析构函数中释放资源，利用对象的生命周期来控制资源。
2. 对 `*` 和 `->` 运算符进行重载，使 `unique_ptr` 对象具有指针一样的行为。
3. 用 C++98 的方式将拷贝构造函数和拷贝赋值函数声明为私有，或者用 C++11 的方式在这两个函数后面加上 `=delete`，防止外部调用。

代码如下：

```cpp
namespace ff
{
	template<class T>
	class unique_ptr
	{
	public:
		//RAII
		unique_ptr(T* ptr = nullptr)
			:m_ptr(ptr)
		{}
		~unique_ptr()
		{
			if (m_ptr != nullptr)
			{
				std::cout << "delete: " << m_ptr << std::endl;
				delete m_ptr;
				m_ptr = nullptr;
			}
		}
		//可以像指针一样使用
		T& operator*()
		{
			return *m_ptr;
		}
		T* operator->()
		{
			return &m_ptr;
		}
		//防拷贝
		unique_ptr(unique_ptr<T>& up) = delete;
		unique_ptr<T>& operator=(unique_ptr<T>& up) = delete;
	private:
		T* m_ptr; //管理的资源
	};
}
```

## std::shared_ptr

### 基本原理

`shared_ptr` 通过**引用计数**的方式解决智能指针的拷贝问题。

- 每一个被管理的资源都有一个对应的引用计数，
  通过这个引用计数记录着当前有多少个对象在管理着这块资源。
- 当新增一个对象管理这块资源时则将该资源对应的引用计数进行 `++`，
  当一个对象不再管理这块资源或该对象被析构时则将该资源对应的引用计数进行 `--`。
- 当一个资源的引用计数减为 $0$ 时说明已经没有对象在管理这块资源了，这时就可以将该资源进行释放了。

通过这种引用计数的方式就能支持多个对象一起管理某一个资源， 也就是支持了智能指针的拷贝，
并且只有当一个资源对应的引用计数减为 $0$ 时才会释放资源，因此保证了同一个资源不会被释放多次。
如下：
```cpp
int main()
{
	std::shared_ptr<int> sp1 = std::make_shared<int>(1);
	{
		std::shared_ptr<int> sp2(sp1);
		std::cout << sp1.use_count() << std::endl; //2
	}
	std::cout << sp1.use_count() << std::endl; //1
	return 0;
}
```

### 模拟实现

简易版的 `shared_ptr` 的实现步骤如下：

1. 在 `shared_ptr` 类中增加一个成员变量 `count`，表示智能指针对象管理的资源对应的引用计数。
2. 在构造函数中获取资源，并将该资源对应的引用计数设置为 $1$，表示当前只有一个对象在管理这个资源。
3. 在拷贝构造函数中，与传入对象一起管理它管理的资源，同时将该资源对应的引用计数 `++`。
4. 在拷贝赋值函数中，先将当前对象管理的资源对应的引用计数 `--`（如果减为 $0$ 则需要释放），
   然后再与传入对象一起管理它管理的资源，同时需要将该资源对应的引用计数 `++`。
5. 在析构函数中，将管理资源对应的引用计数 `--`，如果减为 $0$ 则需要将该资源释放。
6. 对 `*` 和 `->` 运算符进行重载，使 `shared_ptr` 对象具有指针一样的行为。

代码如下：
```cpp
namespace ff
{
	template<class T>
	class shared_ptr
	{
	public:
		//RAII
		shared_ptr(T* ptr = nullptr)
			: m_ptr(ptr)
			, m_count(new int(1))
		{}
		~shared_ptr()
		{
			if (--(*m_count) == 0)
			{
				if (m_ptr != nullptr)
				{
					std::cout << "delete: " << m_ptr << std::endl;
					delete m_ptr;
					m_ptr = nullptr;
				}
				delete m_count;
				m_count = nullptr;
			}
		}
		shared_ptr(shared_ptr<T>& sp)
			: m_ptr(sp.m_ptr)
			, m_count(sp.m_count)
		{
			(*m_count)++;
		}
		shared_ptr<T>& operator=(shared_ptr<T>& sp)
		{
			if (m_ptr != sp.m_ptr) //管理同一块空间的对象之间无需进行赋值操作
			{
				if (--(*m_count) == 0) //将管理的资源对应的引用计数--
				{
					if (m_ptr != nullptr)
					{
						std::cout << "delete:" << m_ptr << std::endl;
						delete m_ptr;
						delete m_count;
					}
				}
				m_ptr = sp.m_ptr;		//与sp对象一同管理它的资源
				m_count = sp.m_count;	//获取sp对象管理的资源对应的引用计数
				(*m_count)++;			//新增一个对象来管理该资源，引用计数++
			}
			return *this;
		}
		//获取引用计数
		int use_count()
		{
			return *m_count;
		}
		//可以像指针一样使用
		T& operator*()
		{
			return *m_ptr;
		}
		T* operator->()
		{
			return &m_ptr;
		}
	private:
		T* m_ptr;		//管理的资源
		int* m_count;	//管理的资源对应的引用计数
	};
}
```

### std::shared_ptr的循环引用问题

```cpp
struct Point
{
	std::shared_ptr<Point> m_prev;
	std::shared_ptr<Point> m_next;
	int m_value;
	Point(int value)
		: m_value(value)
	{
		m_prev = nullptr;
		m_next = nullptr;
	}
	~Point()
	{
		std::cout << "delete: " << m_value << std::endl;
	}
};
int main()
{
	std::shared_ptr<Point> sp1 = std::make_shared<Point>(1);
	std::shared_ptr<Point> sp2 = std::make_shared<Point>(2);
	sp1->m_next = sp2;
	sp2->m_prev = sp1;
	return 0;
}
```